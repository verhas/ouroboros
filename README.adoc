= Ouroboros (ur)

image::logo.svg[Ouroboros logo, align="left" width=100]

A minimal interpreter for a minimal language inspired by TCL, LISP and Forth.
Ouroboros or 'ur' for short, has no syntax at all.
It is just a list of tokens.
The tokens represent commands, constants or variables which are executed from left to right.
Whenever a command is executed, it can, at its discretion, consume subsequent tokens.

The lexical analysis is performed on demand.
It means that only the code to be executed is tokenized.
The rest of the source code is just a string and it is available to read and to modify for the running code.
It means that the program can define new commands, new syntax or even new data types.

The programming language can define itself, hence the name Ouroboros, the snake that eats its own tail.
At the same time the language is minimalistic, hence the abbreviation 'ur', meaning original, quintessential.

The language was developed as research and was not meant for practical use.









== Introduction

This interpreter is executing the simplest syntax possible.
A program is nothing else than a list of tokens.
A bare word can represent a variable or a command.
When a command is called, it can consume the subsequent tokens.

=== `puts` Writing the Output

For example:


.puts.ur source
[source]
----
puts "Hello, World!"

----



will result in:


.puts.ur output
[source]
----
Hello, World!
----


`puts` is a command that prints its argument as a string.
The argument is the string "Hello, World!".
In this case this is a literal, but it can also be more complex, something to evaluate before outputting.

=== Expressions

There are no expressions in the language.
Commands just fetch the next token and interpret it.

For example, the following sample:


.putsadd.ur source
[source]
----
puts add "Hello, " "World!"
puts "\n"
puts add 2 2
puts "\n"
puts add "2" 2
puts "\n"
puts add BigDecimal "2222222222222222222222222222" 2
puts "\n"
puts add 2.3 5

----



will result again in:


.putsadd.ur output
[source]
----
Hello, World!
4
22
2222222222222222222222222224
7.3
----


In this case the expression is the concatenation of two strings.
As `puts` starts to execute it takes one argument.
Taking this argument recognizes `add` as a command.
`add` takes two arguments and if they are strings, it concatenates them.
Finally, the result is printed.

=== Variables

Variables can be assigned with the `set` command.
Variables are always local to the block they are defined in.
If you want to redefine a variable at the top level, you can use the `setg` command.
The name `setg` stands for "set global".
Using `set` on the global level is the same as `setg`.

When you use the command `setn` update a variable already defined in a different block, it will update the variable in the block where it was defined.

You can also set a field of an object with the `setf` command.
In this case the first parameter is the object, and the second is the field name followed by the value.

There is another set command `sets` that sets the remaining source code.
It is detailed later.

Example for the commands `set`, `setg` and `setf`:


.set.ur source
[source]
----
set a "Hello, "
{
  puts a
  puts "\n"
  set a "World!"
  puts a
  puts "\n"
  setg a "Gruetzi, "
  puts a
  puts "\n"
}
puts a

----



will result in:


.set.ur output
[source]
----
Hello, 
World!
World!
Gruetzi, 
----


The first `puts` command prints "Hello, " using the global variabel `a`.
The second `puts` command prints "World!" using the local variable `a`.

After this we alter the global `a`, but while we are still in the block the next `puts` command still prints "World!".
Finally, stepping out of the block the last `puts` command prints "Gruetzi, ".

To set a field of an object is done using `setf`.
To do that, we need to have an object, that can be sone with the `object` command.


.object.ur source
[source]
----
set obj object {}
setf obj name "Hello, "
{
  puts field obj name
  puts "World!"
}

----



will result in:


.object.ur output
[source]
----
Hello, World!
----


We set the variable `obj` to an object.
The argument of the command `object` is the parent object to inherit from.
In this case it is an empty block, so the object has no parent.
Blocks are explained in the section "Blocks".

Then we set the field `name` of the object to `"Hello, "`.
Finally, we print the field `name` of the object using the command `field` and `"World!"`.

=== Data types

The language handles any data type that commands can handle.
The commands that come with the interpreter build in handle `Long`, `Double`, `String` and `Boolean`, objects and lists off the shelf.

`BigDecimal` and `BigInteger` are also supported, but you cannot specify literal constants for them.
To do that,am dededededededededededed you can alter the lexical analyzer or simply use the commands `BigInteger` and `BigDecimal`.
These each consume a string argument and return the corresponding object.

=== Blocks

A block is a series of commands one after the other surrounded by curly braces.
For example:


.block.ur source
[source]
----
puts {
  puts "Hello, "
  "World!"
}

----



will result in:


.block.ur output
[source]
----
Hello, World!
----


The commands in the blocks are evaluated one ofter the other, and the value of the block is the value of the last command.
In this case, the first `puts` command evaluates the block.
During the block evaluation the `puts` commands is executed first, and the result is the value of the string, which is the last command.

`puts` results the string it printed out.

=== Objects, Functions and Methods

Objects are a collection of fields.
Note that methods are also filed with an executable block as their value.
You can create an object with the `object` command.
The command has one argument, the parent object.
During creation the object will copy all fields from the parent object.
There are no classes, only objects.

Functions are nothing else than blocks assigned to a variable.
You can call a function by the name, and then it will evaluate the block.

However, you have to be careful.
If you assign a block to a variable, make sure that you assign the block and not the evaluated result of the block.
For example, the following code will not work:


.err_unquoted.ur source
[source]
----
set a { puts shift }
a "Hello, World!"

----



It will result in an exception:


.err_unquoted.ur output
[source]
----
OUTPUT BEFORE ERROR: 
ERROR: Variable 'a' is not defined
----


The reason is that the block is evaluated before it is assigned to the variable `a`.
During the evaluation it tries to get the next argument calling `shift` and that is `a`.
At this point `a` is not defined yet.

The correct example is:


.quoted.ur source
[source]
----
set a '{ puts shift }
a "Hello, World!"

----



that results in


.quoted.ur output
[source]
----
Hello, World!
----


The command `quote` also abbreviated as `'` will fetch the next element without evaluating it.
It will be assigned as a block that will be evaluated when the variable is used as a command.

Methods are functions that are assigned to an object field.
They cannot be called directly.
To call a method, you need the command `call`.


.method.ur source
[source]
----
set a object{}
setf a b '{puts shift puts field this name puts "!"}
setf a name "World"
call a b "Hello, "

----



It will result in:


.method.ur output
[source]
----
Hello, World!
----


The program defines an object and sets the variable `a` to the object.
Then it sets the field `b` of the object to a block.
After that is sets the field `name` of the object to `"World"`.
Finally, it calls the method `b` of the object `a` with the arguments `"Hello, "`.

When the call is executed, the interpreter will assign the objet to the variable `this`.

When you execute a block, the value of the block is the value of the last command in the block.
Every block has a local scope, and when you define a variable in a block, it is only available in this block.
There are three special variables that are always available inside a block: `$`, `pass:[$$]`, and `$it`.

* `$` is an object representing the current block.

* `pass:[$$]` is the surrounding block.
The fields of these objects are the variables of the block.

* `$it` is the block itself.
Note that this variable is also available for the parent block via the `$$` variable as a field.
The following example shows a simple stack trace implementation:
+

.stackTrace.ur source
[source]
----
set stack {}
set stackTrace '{
  setn stack field? $$ $$ "whoever was calling this function"
  set i 1 "only to count the stack frames"
  while{ stack }{
    puts add* " " i ": " field? stack $it "\n" {}
    setn stack field? stack $$
    setn i add i 1
  }
}
set fun4 '{ stackTrace }
set fun3 '{       fun4 }
set fun2 '{       fun3 }
set fun1 '{       fun2 }
fun1

----


+

.stackTrace.ur output
[source]
----
 1: {fun4}
 2: {fun3}
 3: {fun2}
 4: fun1

----

== Commands


Ouroboros comes with built-in commands.
The command set is minimal, but it can be extended.


=== arg
Get the argument following the block without evaluation.

This command is similar to the command `shift`, but it does not evaluate the argument.
It has the similar effect as quoting the argument and then calling shift.

This command can be used to create commands (functions, methods) that evaluate some of the arguments conditionally.


=== at
Get the element at the given index.
The position is zero-based.
The argument is either a list or a string.

 * Example:


.list_get.ur source
[source]
----
set i list {0 1 2 3 4 5}
puts at i 1

----



will result in


.list_get.ur output
[source]
----
1
----



=== BareWord

Bare word is an internal command that is used to execute a bare word.
You will not use this command in the language.
This is the command created by the lexical analysis when a bare word is found.
In turn, then this command will look up the actual command associated with that bare word at the time and location of the execution.
It will consult the context and the variables and execute the command that is found.


=== BigDecimal
Create a big decimal value.
The argument the command uses is the value and converts it to big decimal.
The argument can be integer, float, boolean, string, or even BigInteger and BigDecimal.

The argument is usually a string.


=== BigInteger
Create a big decimal value.
The argument the command uses is the value and converts it to big integer.
The argument can be integer, float, boolean, string, or even BigInteger and BigDecimal.

The argument is usually a string.


=== binop: binary operations

Binary operations are operations that take two arguments and return a value.
Each of the operations can also be used having the `*` as the first argument.
In this case the operation is applied to all the arguments in the stack till the end of the input or until an `{}` is found.
The first case, when all the arguments are processed can be used when this command is the last one in the command list in the mail level or inside a block.


.binop.ur source
[source]
----
"simple binary operation adding 2 and 2:"
puts add 2 2
"multiple addition till there is a closing {}:"
puts add* 2 2 2 2 {}
"multiple addition till there are no more tokens to fetch on the given level to add:"
puts {add* 2 2 2 2}

----



will result in


.binop.ur output
[source]
----
488
----



In the case of logical operators, like `and` and `or` the operation is NOT short circuit.
This means that all the arguments are evaluated.

=== binop: add

Add values.
The values can be numbers or strings.
If the values are numbers, then the result is the sum of the numbers.
If the values are strings, then the result is the concatenation of the strings.

 * Example:


.putsadd.ur source
[source]
----
puts add "Hello, " "World!"
puts "\n"
puts add 2 2
puts "\n"
puts add "2" 2
puts "\n"
puts add BigDecimal "2222222222222222222222222222" 2
puts "\n"
puts add 2.3 5

----



will result in


.putsadd.ur output
[source]
----
Hello, World!
4
22
2222222222222222222222222224
7.3
----



=== binop: and

Logical and operation.


=== binop: div

Divide values.
The values can only be numbers.

 * Example:


.putsdiv.ur source
[source]
----
puts div 55 13
puts "\n"
puts div 55.0 13
puts "\n"
puts div BigDecimal 10 3
puts "\n"
set $scale 10
set $round "CEILING"
puts div BigDecimal 10 3

----



will result in


.putsdiv.ur output
[source]
----
4
4.230769230769231
3.33
3.3333333334
----


When dividing BigDecimal values the scale and the rounding is defined by the local variables `$scale` and `$round`.
The default scale is 2 and the default rounding is `HALF_UP`.

Rounding modes are

* `UP`
* `DOWN`
* `CEILING`
* `FLOOR`
* `HALF_UP`
* `HALF_DOWN`
* `HALF_EVEN`, and
* `UNNECESSARY`

=== binop: eq
Compare two values.
The command compares two values and returns true if they are equal.


=== binop: ge
Compare two values for greater or equal.
The command compares two values and returns true if the first is greater or equal than the second, and optionally the further arguments.


=== binop: gt
Compare two values for greater.
The command compares two values and returns true if the first is greater than the second, and optionally the further arguments.


=== binop: le
Compare two values for less or equal.
The command compares two values and returns true if the first is less or equal than the second, and optionally the further arguments.


=== binop: lt
Compare two values for less.
The command compares two values and returns true if the first is less than the second, and optionally the further arguments.


=== binop: mod
Calculate the modulus of two numbers.

The command calculates the modulus of the two numbers. The modulus is the remainder of the division of the first number by the second.


=== binop: mul
Multiply two or more values.
The command multiplies two or more values and returns the result.


=== binop: ne
Compare two values for not equal.
The command compares two values and returns true if the first is not equal to the second, and optionally the further arguments.


=== binop: sub
Subtract two values.
The command subtracts the second and optionally the further values from the first and returns the result.


=== binop: or
Logical OR.
The command calculates the logical OR of the two boolean values.
The evaluation is NOT short-circuiting.


=== Block
This command is used to execute a block.
A block is not represented by a bareword; rather, it is represented by a `{` and `}` pair.
The block is a sequence of commands that are executed one after the other.
The block can contain other blocks.

The block is executed in a new context.
Variables defined within the block are not visible outside the block.
However, the block can access variables defined outside of it.
The special variable `$` is set to the value of the context object when the block is executed.
The special variable `$$` is set to the variables defined in the context object of the surrounding block.

The context object is an object that has the local variables as fields.

 * Example:


.block.ur source
[source]
----
puts {
  puts "Hello, "
  "World!"
}

----



will result in


.block.ur output
[source]
----
Hello, World!
----


=== boolean
Create a boolean value.

The argument the command uses is the value and converts it to boolean.
The argument can be an integer, a floating point number, BigInteger, BigDecimal, string, boolean, or null.

=== bw
Create a bare word from a string.


=== call
Calls a method on an object.

The first argument is the object that contains the method.
The second argument is the name of the method to be called.

During execution, the method can accept additional arguments, similar to a function call.
The `this` variable is set to the object that contains the method during its execution.

 * Example:


.call.ur source
[source]
----
set obj object{}
setf obj method '{
   puts field this greeting
   puts shift
}
setf obj greeting "Hello, "
call obj method "World!"

----



will result in


.call.ur output
[source]
----
Hello, World!
----



=== closure

Creates a new closure from a block.
The block is the argument of the command, and in practical cases it has to be quoted.

A closure is a block of code that preserves the environment where it was created.
If there is a variable defined as `x` in the environment where the closure is created, then this will be available when the closure runs.
 * Example:


.simple_closure.ur source
[source]
----
{
  set localVariable "Hello, World!"
  setg f closure ' { puts localVariable }
}
f

----



will result in


.simple_closure.ur output
[source]
----
Hello, World!
----


It will print `"Hello, World!"` even though the variable `localVariable` is not defined outside the block.

Closures inherit ALL levels of the context they are created and this contex closure will have precedence over the actual context.
For example, it is possible to redefine the `puts` command inside a closure and still use the original when the closure runs:

 * Example:


.redefine_puts.ur source
[source]
----
set puts closure quote {puts "--" puts shift puts "--\n" }
puts "Hello, World!"
puts "Hello, Ouroboros!"

----



will result in


.redefine_puts.ur output
[source]
----
--Hello, World!--
--Hello, Ouroboros!--

----


When the closure runs, it still uses the `puts` command that was defined in the global context by the time the closure was created.
When using the `puts` later, it is already calling the closure.

Closures can also be used to create higher order functions.

 * Example:


.high_order_func.ur source
[source]
----
set greet quote {
   set z shift
   closure '{puts add "Hello " z }
   }
set ga greet "Agnieszka"
set gb greet "Bartek"
ga
puts "\n"
gb

----



will result in


.high_order_func.ur output
[source]
----
Hello Agnieszka
Hello Bartek
----


In this case the function `greet` creates two closures during the two invocations, and each resulting closure will have it's own value for the variable `z`.

Finally, if you find it cumbersome to write `clsoure` and `'` all the time, you can define a symbol for the combination like in the following example.

 * Example:


.closure_quote.ur source
[source]
----
set ` '{ closure arg }
setg $symbolChars add $symbolChars "`"
set puts `{puts "--" puts shift puts "--\n" }
puts "Hello, World!"
puts "Hello, Ouroboros!"

----



will result in


.closure_quote.ur output
[source]
----
--Hello, World!--
--Hello, Ouroboros!--

----


In the example, the `$symbolChars` gets the back-tick ``pass:[`]`` character appended to the value.
This global variable contains the characters that should be interpteted as symbols alone.
This will make the use of ``pass:[`{]`` as two symbols instead of one and allows you to use these in the example
without a space in between.

=== copy

Create a deep copy of and object.

 * Example:


.copy.ur source
[source]
----
set A object{}
setf A f1 "racecar"
setf A f2 "tacocat"
set B 'A
set C copy A
setf B f1 "trabant"
setf C f2 "gulash"
puts field A f1
puts "\n"
puts field A f2

----



will result in


.copy.ur output
[source]
----
trabant
tacocat
----



The program creates an object `A` with two fields `f1` and `f2`.
Then it creates a block `B` that references the object `A`.
The program also creates a copy of the object `A` and assigns it to the variable `C`.
After that, it sets the field `f1` of the object `B` to `"trabant"` and the field `f2` of the object `C` to `"gulash"`.
Finally, it prints the values of the fields `f1` and `f2` of the object `A`.
Since the variable `B` references the object `A`, the field `f1` of the object `A` is changed to `"trabant"`.
On the other hands, when we change the field `f2` of the object `C`, the object `A` remains unchanged because the variable `C` is a copy of the object `A`.



=== double
Create a double value.
The argument the command uses is the value and converts it to double.
The argument can be integer, float, boolean, string, or even BigInteger and BigDecimal.


=== double_constant
A number that conforms to the Java double type.
If a floating number literal is present in the code, the lexical analyzers will create a double constant from it.
The double constant is a constant that holds a double value.

=== error
Stop the execution with an error.
The argument of the command is the error message.


=== eval
Evaluate the argument string as program code using the current syntax setup.
Note that the lexical analysers can be modified during the code execution.
This evaluation uses the lexical analysers that are currentlyin use at the execution level.

 * Example:


.eval.ur source
[source]
----
eval puts """{
    puts "Hello, "
    puts "World!"
  }
  "will print out"
"""

----



will result in


.eval.ur output
[source]
----
{
    puts "Hello, "
    puts "World!"
  }
  "will print out"
Hello, World!
----




=== fetch

This command reads the source code of the application and returns the next token invoking the registered lexers.
This command is invoked by the interpreter, and it is not expected to be used in the application code.
It can be overridden by the application code to provide a custom code reader.

=== field

Get an object's field's value.
The fist argument is the object, and the second argument is the name of the field.
When the first argument is `*` then the command will fetch the subsequent arguments and navigate alon g the path of fields in the object structure.
The navigation stops when there are no more fields, or a `{}`.

 * Example:


.field.ur source
[source]
----
set A object {}
setf A f1 "racecar"
setf A f2 "tacocat"
puts field A f1
puts "\n"
puts field A f2

----



will result in


.field.ur output
[source]
----
racecar
tacocat
----


=== first, car

Fetch and return the first element of a list.
The argument is the list.
The command is also registered as `car` to follow the LISP tradition.

 * Example:


.list_first.ur source
[source]
----
set i list {0 1 2 3 4 5}
puts first i

----



will result in


.list_first.ur output
[source]
----
0
----



=== fixup

Fix up the source converting all remaining characters of the current source to tokens.
After this command is executed, the lexical analyzer changes are not applied to the source anymore.
The actual execution of the code is not affected by the command.
This command can be used to signal that the part of the code redefining the syntax is over.
Other implementations may override the default implementation of this command and do something else, like converting the remaining tokens to some target language.

 * Example:


.fixup.ur source
[source]
----
fixup insert $lex 0 '{
if { eq at source 0 "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



will result in


.fixup.ur output
[source]
----
6
----


 * Example:


.nofixup.ur source
[source]
----
insert $lex 0 '{
if { eq at source 0 "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



will result in


.nofixup.ur output
[source]
----
5
----




The sample `fixup.ur` first executes the `fixup` command.
The command then reads all the remaining source code as input and replaces the input string with a list of tokens.
After that, the program inserts a new lexical analyzer into the list `$lex` at the beginning.
This lexical analyzer is NEVER invoked since the code is already tokenized.
Because of that, the addition command presented as `add*`, which means it will read all the arguments until the end of the block, or until `{}` is found, and will add `3`, `2`, and `1`.

In the second case, there is no `fixup`.
The syntax analyzer fetches only as much from the input source string as needed and no more.
First, the command `call` is identified by the built-in lexical analyzer as a bare word, and since it is a command, it will be executed.
The command `call` will fetch the next two arguments to get the object and the method.
When it fetches the arguments, the interpreter invokes the lexical analyzers to get the arguments.
The rest of the input is not tokenized and is available as a string, including and following the space before `0 '{`.
The arguments for the call are `$lex` and `insert`.
Invoking `insert` on the list object advances the lexical analysis further.
The next argument is the position to insert a new value in the list; this is `0`.
The element to insert is a quoted block, which will also be tokenized and, as a block command, gets inserted into the list.
The block does not execute at this point.

Now, the source code string contains the part that starts with `set q add* ...`.
As the execution advances, it reads on, but this time -- without detailing the intermediate steps -- it will also use the inserted lexical analyzer.
When this analyzer encounters the new line, it will replace it with an empty block in the source.
That way, the source will be transformed on the fly to `set q add* 3 2 {} 1 {} ...`.
The addition is performed and the value is assigned to the variable `q`.
The commands `1` and `{}` are executed and ignored.
Finally, the result of the addition is printed.




=== if

If the first argument is `true`, the second argument is executed, otherwise the third one.

The command returns the value of the executed block.

The third argument may be missing or be `{}`.
Note that it can only be missing if the `if` command is the last command of the program or in a block.

 * Example:


.if.ur source
[source]
----
set i 0
while { lt i 10 } {
  if { mod i 2 } {
    puts i
  }{}
  setg i add i 1
}

----



will result in


.if.ur output
[source]
----
13579
----


=== include
Include a file in the input.


=== indexOf
Returnt he index of the string in the second string where it appears in the second string or -1 if the first string
is not part of the second.

=== insert
The command inserts an element into a list at a given position.
The position is zero-based.

The first argument is the list.
The second argument is the index.
The third argument is the value.

 * Example:


.list_insert.ur source
[source]
----
set i list {0 1 2 3 4 5}
insert i 1 99
puts i

----



will result in


.list_insert.ur output
[source]
----
[0, 99, 1, 2, 3, 4, 5]
----


=== isBlank
Check if the string is blank.
The command returns true if the string is blank.

=== isEmpty
Check if the string is empty.
The command returns true if the string is empty.

=== last

The command returns the last element of the list.
The argument is the list.

 * Example:


.list_last.ur source
[source]
----
set i list {0 1 2 3 4 5}
puts last i

----



will result in


.list_last.ur output
[source]
----
5
----



=== length
Get the length of the string or a list.
The command returns the length of the string or a list.

=== lexers

Lexical analyzers are also commands in the interpreter.
They read the source code and decide if they can read a token from the source.
If they can, they read the token and return it after modifying the source, chopping off the consumed part.

The lexical analysers are called one after the other until one of them can read a token.

When a lexical analyser returns a null value (not null, but a Value that contains null) it means that the analysis did eat some token, but it is to be ignored.
Typically, the space lexer returns a null value when it reads a space character.

When this happens, the lexical analysis starts over with the first lexer.


=== lexer: $keyword

Get the next word from the source that is formally a valid identifier.
It will be a bare word that may represent a command or a value based on the context.
Return `null` if the next token is not a valid identifier.


=== lexer: $block

A lexer that consumes a block of commands.

The block of commands starts with a `{` character and ends with a `}` character.
When the parser finds the opening `{` character it starts to read the commands with a recursive call until the next command is a CommandBlockClose.
That way blocks can be nested.


=== lexer: $blockClose

A lexer that consumes the closing block character '}'.
It returns a CommandBlockClose command, which should and never will execute.
It is a technical placeholder.


=== lexer: $blockOpen

A lexer that consumes the opening block character '{'.
It returns a CommandBlockOpen command, which should and never will execute.
It is a technical placeholder.


=== lexer: $number

Fetches a numeric constant from the input.
It can be decimal or hexadecimal, integer or double.
Also note that the lexer handles the Java hexadecimal floating point, because why not.

=== lexers: $space

Fetches one or more white spaces from the input.
It returns `null` so that the white spaces are simple token separators and no command is created from them.

Note that returning `null` and returning `null` value (an instance of `SimpleValue` with `null` value) are different things.
The `null` return value means that the lexer consumed no input.
The `null` simple value means that there were characters on the input that the lexer consumed, but there is no created command or value.


=== lexer: $string

Fetches a string constant from the input.
It can be a simple string or a multi-line string.

Multi-line strings start with three `"` characters and they so not need escaping for single `"` quotes

=== lexers: $symbol

Fetches one or more symbol characters from the input.
It returns a BareWord that is a symbol.

A symbol is a character or a sequence of characters that are not a valid Java identifier, and do not contain whitespace or digits or the characters '{' and '}'.


=== list

Creates a list object.

The argument can be a block or a command.
When it is a block, then the commands in the block are evaluated individually and the results are added to the list.
If the argument is a single command, then the command is evaluated and the result is the initial single element of the list.

These are documented as commands, but you can invoke them as methods of the list object using the command `call`.

 * Example:


.list.ur source
[source]
----
set i list {1 2 3 4 5}
puts i

----



will result in


.list.ur output
[source]
----
[1, 2, 3, 4, 5]
----


=== long
Create a long value.
The argument the command uses is the value and converts it to long.
The argument can be integer, float, boolean, string, or even BigInteger and BigDecimal.


=== long_constant
A number that conforms to the Java long type.
If an integer number literal is present in the code, the lexical analyzers will create a long constant from it.
The long constant is a constant that holds a long value.

=== match
Check if the string matches the regular expression.
The command returns true if the string matches the regular expression.

=== not
Negate the value.
The command negates the value. If the value is true then the result is false and if the value is false then the result is true.

=== object

Create a new object.
The argument is the parent object.
The new object will inherit all the fields from the parent object.
The inheritance happens using shallow copy.

If the argument is `{}` then the new object will be empty at the creation.

 * Example:


.object_complex.ur source
[source]
----
set A object {}
set B object {}
setf B f "tacocat"
setf A b B
set C object A
setf field C b f "gulash"
puts field* A b f {}
setf field C b object {}
puts add "\n" field* A b f {}

----



will result in


.object_complex.ur output
[source]
----
gulash
gulash
----




We create two objects `A` and `B`.
The object `B` has a field `f` with the value `"tacocat"`.
The object `A` has a field `b` that references the object `B`.
Then we create an object `C` that inherits the fields of `A`.
If we set the field `f` of the object `B` to `"gulash"` through the object `C`, the field `f` of the object `B` will be changed to `"gulash"`.
It is the same and only instance of `B`.

Now if we set the field `b` of the object `C` to an empty object, the field `b` of object `A` does not change.
`C` only inherits the fields from `A` and the change there does not affect `A`.



            "version",
            "output",
            "include",
            "help"

=== puts
Print the value as a string.

 * Example:


.puts.ur source
[source]
----
puts "Hello, World!"

----



will result in


.puts.ur output
[source]
----
Hello, World!
----


=== quote

Return the argument as a value without evaluating it.
The command can be used as `quote` but it is also abbreviated as `'`.

 * Example:


.quote.ur source
[source]
----
set hi quote { puts shift puts shift}
hi "Hello, " "World!"

----



will result in


.quote.ur output
[source]
----
Hello, World!
----


=== replace
Replace the target string with the replacement string in the string.
The command returns the string where the target string is replaced with the replacement string.

=== replaceAll
Replace the target string with the replacement string in the string.
The first argument is the source string, the second argument is a regular expression, and the third argument is the replacement string.
The command returns the string where all matching occurrence of the regular expression is replaced with the replacement string.

=== replaceFirst
Replace the target string with the replacement string in the string.
The first argument is the source string, the second argument is a regular expression, and the third argument is the replacement string.
The command returns the string where the first matching occurrence of the regular expression is replaced with the replacement string.

=== rest, cdr
This command returns a new list that contains all the elements of the list except the first one.
If the list is empty, then the command throws an exception.
The argument is the list.

The command is also registered as `cdr` to follow the LISP tradition.

 * Example:


.list_rest.ur source
[source]
----
set i list {0 1 2 3 4 5}
puts rest i

----



will result in


.list_rest.ur output
[source]
----
[1, 2, 3, 4, 5]
----



=== set
Set a variable in the context.

The first argument is the name of the variable, and the second argument is the value.

 * Example:


.set1.ur source
[source]
----
set A "Hello "
{ puts A set A "World!" } puts A
puts "\n"
set A "Hello "
{ puts A setg A "Gruetzi" } puts A
puts "\n"
setf $ A "Hello "
{ puts A setf $$ A "Ciao" } puts A

----



will result in


.set1.ur output
[source]
----
Hello Hello 
Hello Gruetzi
Hello Ciao
----




The program sets the variable `A` to `"Hello "`.
Then it prints the value of `A` and sets `A` to `"World!"`.
This setting, however, is only valid within the block.
After the block, the value of `A` is still `"Hello "`.

In the next section we set `A` to `"Hello "` again.
This time we use the `setg` command to set the global variable `A` to `"Gruetzi"`.
After the block, the value of `A` is `"Gruetzi"`.

Tne next section sets the variable `A` as a field of the object `$`.
This variable is available in all environments and it is the object that has all the variables on that level as fields.
Then it prints the value of `A` and sets the variable `A` to `"Ciao"`.
This time it sets this variable as the field of the object `$$`.
This variable is only available in side blocks and they represent the object that has all the variables on the enclosing level as fields.



=== setf
Set a field in an object.
The first argument is the object, the second argument is the name of the field, and the third argument is the value.

Example:


.setf1.ur source
[source]
----
set A object{}
setf A f1 "racecar"
puts field A f1

----



will result in


.setf1.ur output
[source]
----
racecar
----


Note also that the symbols `$` is always available and points to the object that contains the local variables.
Similarly, the `pass:[$$]` symbol is also available except the top scope, and it points to the object that contains the local variables of the one level above.
You can also reach `pass:[$$]` as a field via `pass:[$$]` traversing the call hierarchy.

The next example sets the local variable `A` and after that it modifies it as a field of `$`.



.setf2.ur source
[source]
----
  { set A "Victor Noir"
  setf $ A  "Yvan Salmon"
  puts A }

----



will result in


.setf2.ur output
[source]
----
Yvan Salmon
----


The next example uses the `pass:[$$]` to set a field in the object that contains the local variables of the caller.


.setf3.ur source
[source]
----
  { set A "Victor Noir\n"
     { set A  "Yvan Salmon\n"
       { set A "Bonaparte\n"
         setf $$ A "Napoleon\n"
         setf field $$ $$ A "Josephine\n"
         puts A
       }
       puts A
     }
  puts A
  }

----



will result in


.setf3.ur output
[source]
----
Bonaparte
Napoleon
Josephine

----


The last example shows that you can assign a function to a field to act as a method.


.setf4.ur source
[source]
----
set A object{}
setf A f1 ' { "racecar" }
puts field A f1
puts "\n"
puts call A f1

----



will result in


.setf4.ur output
[source]
----
{"""racecar"""}
racecar
----


=== setg
Set a global variable in the context.
The first argument is the name of the variable, and the second argument is the value.

=== setl
Set the element of a list at some position.
The position is zero-based.
The first argument is the list.
The second argument is the index.
The third argument is the value.

 * Example:


.list_set.ur source
[source]
----
set i list {0 1 2 3 4 5}
setl i 1 99
puts i

----



will result in


.list_set.ur output
[source]
----
[0, 99, 2, 3, 4, 5]
----


=== setn
Alter the value of a variable.

The first argument is the name of the variable, and the second argument is the value.

The difference between this command and set is that this command will first search for the variable.
If there is already a variable with the given name, it will alter the value of that variable instead of creating a
new one shadowing it in the local block.

If the variable was not defined it will define it in the current.

 * Example:


.setn1.ur source
[source]
----
set A "Hello, "
puts {
    puts A
    setn A "Gruetzi, "
    set A "World!"
    setn A "Welt!"
}
puts A

----



will result in


.setn1.ur output
[source]
----
Hello, Welt!Gruetzi, 
----




The program sets the global variable `A` to `"Hello, "`.
Then it prints the value of `A` and sets `A` to `"Gruetzi, "`.
This time it sets the global variable `A` to `"Gruetzi, "` calling the `setn` command.
The next command creates a local variable `A` and sets it to `"World!"`.
The following `setn` command sets this local variable `A` to `"Welt!"`.
Since it is returned and it is the last value in the block it is printed.

After the block, the global variable `A` is still `"Gruetzi, "`.



=== sets

Set the remaining source that was not processed yet.

=== shift

Get the argument following the block with evaluation.

The pair of the commands is `arg` that fetched the next argument without evaluation.


=== source

Get the remaining source that was not processed yet.

=== split
This command splits a list into two lists at a given index.
The index is zero-based.
The method returns a list of two lists.
The first list contains the elements from the beginning of the list up to the index.
The second list contains the elements from the index to the end of the list.

 * Example:


.list_split.ur source
[source]
----
set i list {0 1 2 3 4 5}
puts split i 2

----



will result in


.list_split.ur output
[source]
----
[[0, 1], [2, 3, 4, 5]]
----


=== string
Convert the argument to string.
The command converts the argument to string.

=== string_constant
A string value.
If a string literal is present in the code, the lexical analyzers will create a string constant from it.
The string constant is a constant that holds a string value.

=== substring
Get the substring of the string.
The command returns the substring of the string.

The first argument is the start index, the second argument is the end index.
The third argument is the string.

If the second argument is `*` then the substring is taken from the start index to the end of the string.

=== switch

The switch command must have an even number of parameters till an `{}` or end of the tokens.
The switch command must be followed by an even number of blocks.
The first, the third and every odd block is evaluated as a condition until one is found `true`.
When a condition is true the even block following the condition is evaluated and the result is returned.
The rest of the conditions and all subsequent blocks are ignored.

 * Example:


.switch1.ur source
[source]
----
set a 1
switch
{eq a 1} {puts 1}
{eq a 2} {puts 2}
{eq a 1} {puts 3}
{}

----



will result in


.switch1.ur output
[source]
----
1
----


The same example can also be written as:

 * Example:


.switch2.ur source
[source]
----
set a 1
{switch
 {eq a 1} {puts 1}
 {eq a 2} {puts 2}
 {eq a 1} {puts 3}
}

----



will result in


.switch2.ur output
[source]
----
1
----



=== tolower
Convert the string to lower-case.
The command returns the string converted to lower-case.

=== toupper
Convert the string to upper-case.
The command returns the string converted to upper-case.

=== trim
Trim the string.
The command returns the string trimmed.

=== while

The first argument is the condition and the second argument is the block.
The command executes the two blocks one after the other while the result of the first block is true.



== Redefining the Language

The language can redefine itself.
Since the end of the code is not tokenized and is available as a string, you can write code that modifies the source extending the original syntax.
The following example will treat every new line as a command closing an empty block.

The operator commands, like `add`, `mult`, `div` and so on can either take two arguments or multiple arguments.
If their first argument is  `*` they will take all the remaining arguments until the end of the block or until an empty block is the next argument.

Writing `{}` many times at the end of the operands following an `add` or `mult` may be cumbersome.
To avoid this, the following program alters the syntax analysis process to treat every new line as a command closing an empty block.


.lexNewLine.ur source
[source]
----
insert $lex 0 '{
if { eq at source 0 "\n"}
   {sets substring 1 length source source '{}}}
set q add* 3 2
1 {} puts q

----



The variable `$lex` is a list that contains all the lexical analyzers.
Lexical analyzers are commands that get the source and either

* return a single token and swallow the characters corresponding to that token from the source, or

* leave the source intact and return `null`.

The code inserts a new lexical analyzer.
This analyzer looks at the start of the source.
If it is a new line, it removes that and inserts an empty block instead.
After that it returns `null`, like if it did not find anything.

The new lexical analyzer is inserted at the beginning of the list.
After this the command `add* 3 2\n` will be treated as `add* 3 2 {}`.
That way this program will result in:


.lexNewLine.ur output
[source]
----
5
----


You can also find other examples in the test cases, for example, `src/test/resources/samples/xpression.ur` contains a script that defines numerical expression parser.

=== Introspect Variables

Variables defined in the interpreter that allows the modification of the code are the followings:


==== `$block`

This variable references the lexer that recognizes a whole block.
This analyzer is more like a syntax analyzer than a lexer.
It will call the interpreter recursively to call the lexers for the commands in the block until it finds a block close.

==== `$blockClose`

This variable references the lexer that recognizes a block end.

==== `$blockOpen`

This variable references the lexer that recognizes a block start.
This lexer is called by the lexer that recognizes a block and is not in the list of alternative lexers.

==== `$keyword`

This variable references the lexer that recognizes a bare word.
It is called keyword, but bear in mind that there are no keywords in UR.


==== `$number`

This variable references the lexer that recognizes a number.

==== `$program`

This variable references the actual code.
The code is a list of list of blocks `List<List<Block>>`.
Using this variable, you can read and manipulate the code that was not executed yet


==== `$space`

This variable references the lexer that recognizes a space.

==== `$string`

This variable references the lexer that recognizes a string.

==== `$symbol`

This variable references the lexer that recognizes a symbol.
This lexer will accept a string that contains symbol characters.
Everything is a symbol character that is not a Java identifier character, not white space, not a digit, and not a block start or end character.