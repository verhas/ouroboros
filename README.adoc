= Ouroboros (ur)

image::logo.svg[Ouroboros logo, align="left" width=100]

A minimal interpreter for a minimal language inspired by TCL, LISP and Forth.
Ouroboros or 'ur' for short, has no syntax at all.
It is just a list of tokens.
The tokens represent commands, constants or variables which are executed from left to right.
Whenever a command is executed, it can, at its discretion, consume subsequent tokens.

The lexical analysis is performed on demand.
It means that only the code to be executed is tokenized.
The rest of the source code is just a string and it is available to read and to modify for the running code.
It means that the program can define new commands, new syntax or even new data types.

The programming language can define itself, hence the name Ouroboros, the snake that eats its own tail.
At the same time the language is minimalistic, hence the abbreviation 'ur', meaning original, quintessential.

The language was developed as research and was not meant for practical use.







== Introduction

This interpreter is executing the simplest syntax possible.
A program is nothing else than a list of tokens.
A bare word can represent a variable or a command.
When a command is called, it can consume the subsequent tokens.

=== `puts` Writing the Output

For example:


.oro source
[source]
----
puts "Hello, World!"

----



will result in:


.Output
[source]
----
Hello, World!
----


`puts` is a command that prints its argument as a string.
The argument is the string "Hello, World!".
In this case this is a literal, but it can also be more complex, something to evaluate before outputting.

=== Expressions

There are no expressions in the language.
Commands just fetch the next token and interpret it.

For example, the following sample:


.oro source
[source]
----
puts add "Hello, " "World!"

----



will result again in:


.Output
[source]
----
Hello, World!
----


In this case the expression is the concatenation of two strings.
As `puts` starts to execute it takes one argument.
Taking this argument recognizes `add` as a command.
`add` takes two arguments and if they are strings, it concatenates them.
Finally, the result is printed.

=== Variables

Variables can be assigned with the `set` command.
Variables are always local to the block they are defined in.
If you want to redefine a variable at the top level, you can use the `setg` command.
The name `setg` stands for "set global".

You can also set a field of an object with the `setf` command.
In this case the first parameter is the object, and the second is the field name followed by the value.

There is another set command `sets` that sets the remaining source code.
It is detailed later.

Example for the commands `set`, `setg` and `setf`:


.oro source
[source]
----
set a "Hello, "
{
  puts a
  puts "\n"
  set a "World!"
  puts a
  puts "\n"
  setg a "Gruetzi, "
  puts a
  puts "\n"
}
puts a

----



will result in:


.Output
[source]
----
Hello, 
World!
World!
Gruetzi, 
----


The first `puts` command prints "Hello, " using the global variabel `a`.
The second `puts` command prints "World!" using the local variable `a`.

After this we alter the global `a`, but while we are still in the block the next `puts` command still prints "World!".
Finally, stepping out of the block the last `puts` command prints "Gruetzi, ".

To set a field of an object is done using `setf`.
To do that, we need to have an object, that can be sone with the `object` command.


.oro source
[source]
----
set obj object {}
setf obj name "Hello, "
{
  puts field obj name
  puts "World!"
}

----



will result in:


.Output
[source]
----
Hello, World!
----


We set the variable `obj` to an object.
The argument of the command `object` is the parent object to inherit from.
In this case it is an empty block, so the object has no parent.
Blocks are explained in the section "Blocks".

Then we set the field `name` of the object to `"Hello, "`.
Finally, we print the field `name` of the object using the command `field` and `"World!"`.

=== Data types

The language handles any data type that commands can handle.
The commands that come with the interpreter build in handle `Long`, `Double`, `String` and `Boolean`, objects and lists off the shelf.


=== Blocks

A block is a series of commands one after the other surrounded by curly braces.
For example:


.oro source
[source]
----
puts {
  puts "Hello, "
  puts "World!"
}

----



will result in:


.Output
[source]
----
Hello, World!World!
----


The commands in the blocks are evaluated one ofter the other, and the value of the block is the value of the last command.
In this case the starting the first `puts` command it evaluates the block.
During the block evaluation the two `puts` commands are executed, and the result is the value of the last `puts` command.

`puts` results the string it printed out.

=== Objects, Functions and Methods

Objects are a collection of fields.
You can create an object with the `object` command.
The command has one argument, the parent object.
During creation the object will copy all fields from the parent object.
There are no classes, only objects.

Functions are nothing else than blocks assigned to a variable.
You can call a function by the name, and then it will evaluate the block.

However, you have to be careful.
If you assign a block to a variable, make sure that you assign the block and not the evaluated result of the block.
For example, the following code will not work:


.oro source
[source]
----
set a { puts shift }
a "Hello, World!"

----



It will result in an exception:


.Output
[source]
----
Variable a is not defined
----


The reason is that the block is evaluated before it is assigned to the variable `a`.
During the evaluation it tries to get the next argument calling `shift` and that is `a`.
At this point `a` is not defined yet.

The correct example is:


.oro source
[source]
----
set a '{ puts shift }
a "Hello, World!"

----



that results in


.Output
[source]
----
Hello, World!
----


The command `quote` also abbreviated as `'` will fetch the next element without evaluating it.
It will be assigned as a block that will be evaluated when the variable is used as a command.

Methods are functions that are assigned to an object field.
They cannot be called directly.
To call a method, you need the command `call`.


.oro source
[source]
----
set a object{}
setf a b '{puts shift puts field this name puts "!"}
setf a name "World"
call a b "Hello, "

----



It will result in:


.Output
[source]
----
Hello, World!
----


The program defines an object and sets the variable `a` to the object.
Then it sets the field `b` of the object to a block.
After that is sets the field `name` of the object to `"World"`.
Finally, it calls the method `b` of the object `a` with the arguments `"Hello, "`.

When the call is executed, the interpreter will assign the objet to the variable `this`.

When you execute a block, the value of the block is the value of the last command in the block.
Every block has a local scope, and when you define a variable in a block, it is only available in this block.
There are two special variables that are always available inside a block: `$` and `pass:[$$]`.
`$` is an object representing the current block.
`pass:[$$]` is the surrounding block.
The fields of these objects are the variables of the block.

== Commands

Ouroboros comes with built-in commands.
The command set is minimal, but it can be extended.


=== copy

Create a deep copy of and object.

=== arg
Get the argument following the block without evaluation.

This command is similar to the command `shift`, but it does not evaluate the argument.
It has the similar effect as quoting the argument and then calling shift.

This command can be used to create commands (functions, methods) that evaluate some of the arguments conditionally.


=== BareWord

Bare word is an internal command that is used to execute a bare word.
You will not use this command in the language.
This is the command created by the lexical analysis when a bare word is found.
In turn, then this command will look up the actual command associated with that bare word at the time and location of the execution.
It will consult the context and the variables and execute the command that is found.


=== Block
This command is used to execute a block.
A block is not represented by a bareword, rather it is represented by a `{` and `}` pair.
The block is a sequence of commands that are executed one after the other.
The block can contain other blocks.

The block is executed in a new context.
The variables that are defined in the block are not visible outside the block.
The block can access the variables defined outside the block.
The special variable `$` is set to the value of the context object when the block is executed.
The special variable `$$` is set to the variables defined in the context object surrounding block.

The context object is an object that has the local variables as fields.


=== call
Call a method.

The first argument is the object that has the method.
The second argument is the name of the method.

During the execution, the method can consume further arguments just like a function call.
During the execution of the method, the `this` variable is set to the object that has the method.


=== eval
Evaluate the argument string as program code using the current syntax setup.

=== field
Get the value of a field of an object.
The fist argument is the object and the second argument is the name of the field.

=== fixup

Fix up the source converting all remaining characters of the current source to tokens.
After this command is executed, the lexical analyzer changes are not applied to the source anymore.
The actual execution of the code is not affected by the command.
This command can be used to signal that the part of the code redefining the syntax is over.
Other implementations may override the default implementation of this command and do something else, like converting the remaining tokens to some target language.


=== if

If the first argument is true then the second argument is executed, otherwise the third argument is executed.

The command returns the value of the executed block.

The third argument may be missing, or be `{}`.
Note that it can only be missing if the `if` command is the last command of the program or a block.


=== object

Create a new object.
The argument is the parent object.
The new object will inherit all the fields from the parent object.
The inheritance happens using shallow copy.

If the arument is `{}` then the new object will be empty at the creation.

=== puts
Print the value as a string.

=== quote

Return the argument as a value without evaluating it.
The command can be used as `quote` but it is also abbreviated as `'`.

=== set
Set a variable in the context.

The first argument is the name of the variable and the second argument is the value.

=== setf
Set a field in an object.
The first argument is the object, the second argument is the name of the field, and the third argument is the value.

=== setg
Set a global variable in the context.
The first argument is the name of the variable, and the second argument is the value.

=== sets

Set the remaining source that was not processed yet.

=== shift

Get the argument following the block with evaluation.


=== source
Get the remaining source that was not processed yet.

=== while

The first argument is the condition and the second argument is the block.
The command executes the two blocks one after the other while the result of the first block is true.



== Redefining the Language

The language can redefine itself.
Since the end of the code is not tokenized and is available as a string, you can write code that modifies the source extending the original syntax.
The following example will treat every new line as a command closing empty block.

The operator commands, like `add`, `mult`, `div` and so on can either take two arguments or multiple arguments.
If their first argument is  `*` they will take all the remaining arguments until the end of the block or until an empty block is the next argument.

Writing `{}` many times at the end of the operands following an `add` or `mult` may be cumbersome.
To avoid this, the following program alters the syntax analysis process to treat every new line as a command closing an empty block.


.oro source
[source]
----
call $lex insert 0 '{
if { eq charAt 0 source "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



The variable `$lex` is a list that contains all the lexical analyzers.
Lexical analyzers are commands that get the source and either

* return a single token and swallow the characters corresponding to that token from the source, or

* leave the source intact and return `null`.

The code inserts a new lexical analyzer.
This analyzer looks at the start of the source.
If it is a new line, it removes that and inserts an empty block instead.
After that it returns `null`, like if it did not find anything.

The new lexical analyzer is inserted at the beginning of the list.
After this the command `add* 3 2\n` will be treated as `add* 3 2 {}`.
That way this program will result in:


.Output
[source]
----
5
----