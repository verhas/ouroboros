= Ouroboros (ur)

image::logo.svg[Ouroboros logo, align="left" width=100]

A minimal interpreter for a minimal language inspired by TCL, LISP and Forth.
Ouroboros or 'ur' for short, has no syntax at all.
It is just a list of tokens.
The tokens represent commands, constants or variables which are executed from left to right.
Whenever a command is executed, it can, at its discretion, consume subsequent tokens.

The lexical analysis is performed on demand.
It means that only the code to be executed is tokenized.
The rest of the source code is just a string and it is available to read and to modify for the running code.
It means that the program can define new commands, new syntax or even new data types.

The programming language can define itself, hence the name Ouroboros, the snake that eats its own tail.
At the same time the language is minimalistic, hence the abbreviation 'ur', meaning original, quintessential.

The language was developed as research and was not meant for practical use.









== Introduction

This interpreter is executing the simplest syntax possible.
A program is nothing else than a list of tokens.
A bare word can represent a variable or a command.
When a command is called, it can consume the subsequent tokens.

=== `puts` Writing the Output

For example:


.puts.ur source
[source]
----
puts "Hello, World!"

----



will result in:


.puts.ur output
[source]
----
Hello, World!
----


`puts` is a command that prints its argument as a string.
The argument is the string "Hello, World!".
In this case this is a literal, but it can also be more complex, something to evaluate before outputting.

=== Expressions

There are no expressions in the language.
Commands just fetch the next token and interpret it.

For example, the following sample:


.putsadd.ur source
[source]
----
puts add "Hello, " "World!"

----



will result again in:


.putsadd.ur output
[source]
----
Hello, World!
----


In this case the expression is the concatenation of two strings.
As `puts` starts to execute it takes one argument.
Taking this argument recognizes `add` as a command.
`add` takes two arguments and if they are strings, it concatenates them.
Finally, the result is printed.

=== Variables

Variables can be assigned with the `set` command.
Variables are always local to the block they are defined in.
If you want to redefine a variable at the top level, you can use the `setg` command.
The name `setg` stands for "set global".

You can also set a field of an object with the `setf` command.
In this case the first parameter is the object, and the second is the field name followed by the value.

There is another set command `sets` that sets the remaining source code.
It is detailed later.

Example for the commands `set`, `setg` and `setf`:


.set.ur source
[source]
----
set a "Hello, "
{
  puts a
  puts "\n"
  set a "World!"
  puts a
  puts "\n"
  setg a "Gruetzi, "
  puts a
  puts "\n"
}
puts a

----



will result in:


.set.ur output
[source]
----
Hello, 
World!
World!
Gruetzi, 
----


The first `puts` command prints "Hello, " using the global variabel `a`.
The second `puts` command prints "World!" using the local variable `a`.

After this we alter the global `a`, but while we are still in the block the next `puts` command still prints "World!".
Finally, stepping out of the block the last `puts` command prints "Gruetzi, ".

To set a field of an object is done using `setf`.
To do that, we need to have an object, that can be sone with the `object` command.


.object.ur source
[source]
----
set obj object {}
setf obj name "Hello, "
{
  puts field obj name
  puts "World!"
}

----



will result in:


.object.ur output
[source]
----
Hello, World!
----


We set the variable `obj` to an object.
The argument of the command `object` is the parent object to inherit from.
In this case it is an empty block, so the object has no parent.
Blocks are explained in the section "Blocks".

Then we set the field `name` of the object to `"Hello, "`.
Finally, we print the field `name` of the object using the command `field` and `"World!"`.

=== Data types

The language handles any data type that commands can handle.
The commands that come with the interpreter build in handle `Long`, `Double`, `String` and `Boolean`, objects and lists off the shelf.


=== Blocks

A block is a series of commands one after the other surrounded by curly braces.
For example:


.block.ur source
[source]
----
puts {
  puts "Hello, "
  "World!"
}

----



will result in:


.block.ur output
[source]
----
Hello, World!
----


The commands in the blocks are evaluated one ofter the other, and the value of the block is the value of the last command.
In this case, the first `puts` command evaluates the block.
During the block evaluation the `puts` commands is executed first, and the result is the value of the string, which is the last command.

`puts` results the string it printed out.

=== Objects, Functions and Methods

Objects are a collection of fields.
You can create an object with the `object` command.
The command has one argument, the parent object.
During creation the object will copy all fields from the parent object.
There are no classes, only objects.

Functions are nothing else than blocks assigned to a variable.
You can call a function by the name, and then it will evaluate the block.

However, you have to be careful.
If you assign a block to a variable, make sure that you assign the block and not the evaluated result of the block.
For example, the following code will not work:


.unquoted.ur source
[source]
----
set a { puts shift }
a "Hello, World!"

----



It will result in an exception:


.unquoted.ur output
[source]
----
Variable a is not defined
----


The reason is that the block is evaluated before it is assigned to the variable `a`.
During the evaluation it tries to get the next argument calling `shift` and that is `a`.
At this point `a` is not defined yet.

The correct example is:


.quoted.ur source
[source]
----
set a '{ puts shift }
a "Hello, World!"

----



that results in


.quoted.ur output
[source]
----
Hello, World!
----


The command `quote` also abbreviated as `'` will fetch the next element without evaluating it.
It will be assigned as a block that will be evaluated when the variable is used as a command.

Methods are functions that are assigned to an object field.
They cannot be called directly.
To call a method, you need the command `call`.


.method.ur source
[source]
----
set a object{}
setf a b '{puts shift puts field this name puts "!"}
setf a name "World"
call a b "Hello, "

----



It will result in:


.method.ur output
[source]
----
Hello, World!
----


The program defines an object and sets the variable `a` to the object.
Then it sets the field `b` of the object to a block.
After that is sets the field `name` of the object to `"World"`.
Finally, it calls the method `b` of the object `a` with the arguments `"Hello, "`.

When the call is executed, the interpreter will assign the objet to the variable `this`.

When you execute a block, the value of the block is the value of the last command in the block.
Every block has a local scope, and when you define a variable in a block, it is only available in this block.
There are two special variables that are always available inside a block: `$` and `pass:[$$]`.
`$` is an object representing the current block.
`pass:[$$]` is the surrounding block.
The fields of these objects are the variables of the block.

== Commands


Ouroboros comes with built-in commands.
The command set is minimal, but it can be extended.


=== arg
Get the argument following the block without evaluation.

This command is similar to the command `shift`, but it does not evaluate the argument.
It has the similar effect as quoting the argument and then calling shift.

This command can be used to create commands (functions, methods) that evaluate some of the arguments conditionally.


=== BareWord

Bare word is an internal command that is used to execute a bare word.
You will not use this command in the language.
This is the command created by the lexical analysis when a bare word is found.
In turn, then this command will look up the actual command associated with that bare word at the time and location of the execution.
It will consult the context and the variables and execute the command that is found.


=== Block
This command is used to execute a block.
A block is not represented by a bareword; rather, it is represented by a `{` and `}` pair.
The block is a sequence of commands that are executed one after the other.
The block can contain other blocks.

The block is executed in a new context.
Variables defined within the block are not visible outside the block.
However, the block can access variables defined outside of it.
The special variable `$` is set to the value of the context object when the block is executed.
The special variable `$$` is set to the variables defined in the context object of the surrounding block.

The context object is an object that has the local variables as fields.

 * Example:


.block.ur source
[source]
----
puts {
  puts "Hello, "
  "World!"
}

----



will result in


.block.ur output
[source]
----
Hello, World!
----


=== call
Calls a method on an object.

The first argument is the object that contains the method.
The second argument is the name of the method to be called.

During execution, the method can accept additional arguments, similar to a function call.
The `this` variable is set to the object that contains the method during its execution.

 * Example:


.call.ur source
[source]
----
set obj object{}
setf obj method '{
   puts field this greeting
   puts shift
}
setf obj greeting "Hello, "
call obj method "World!"

----



will result in


.call.ur output
[source]
----
Hello, World!
----



=== copy

Create a deep copy of and object.

 * Example:


.copy.ur source
[source]
----
set A object{}
setf A f1 "racecar"
setf A f2 "tacocat"
set B 'A
set C copy A
setf B f1 "trabant"
setf C f2 "gulash"
puts field A f1
puts "\n"
puts field A f2

----



will result in


.copy.ur output
[source]
----
trabant
tacocat
----



The program creates an object `A` with two fields `f1` and `f2`.
Then it creates a block `B` that references the object `A`.
The program also creates a copy of the object `A` and assigns it to the variable `C`.
After that, it sets the field `f1` of the object `B` to `"trabant"` and the field `f2` of the object `C` to `"gulash"`.
Finally, it prints the values of the fields `f1` and `f2` of the object `A`.
Since the variable `B` references the object `A`, the field `f1` of the object `A` is changed to `"trabant"`.
On the other hands, when we change the field `f2` of the object `C`, the object `A` remains unchanged because the variable `C` is a copy of the object `A`.



=== eval
Evaluate the argument string as program code using the current syntax setup.
Note that the lexical analysers can be modified during the code execution.
This evaluation uses the lexical analysers that are currentlyin use at the execution level.

 * Example:


.eval.ur source
[source]
----
eval puts """{
    puts "Hello, "
    puts "World!"
  }
  "will print out"
"""

----



will result in


.eval.ur output
[source]
----
{
    puts "Hello, "
    puts "World!"
  }
  "will print out"
Hello, World!
----




=== field
Get an object's field's value.
The fist argument is the object, and the second argument is the name of the field.

 * Example:


.field.ur source
[source]
----
set A object {}
setf A f1 "racecar"
setf A f2 "tacocat"
puts field A f1
puts "\n"
puts field A f2

----



will result in


.field.ur output
[source]
----
racecar
tacocat
----


=== fixup

Fix up the source converting all remaining characters of the current source to tokens.
After this command is executed, the lexical analyzer changes are not applied to the source anymore.
The actual execution of the code is not affected by the command.
This command can be used to signal that the part of the code redefining the syntax is over.
Other implementations may override the default implementation of this command and do something else, like converting the remaining tokens to some target language.

 * Example:


.fixup.ur source
[source]
----
fixup call $lex insert 0 '{
if { eq charAt 0 source "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



will result in


.fixup.ur output
[source]
----
6
----


 * Example:


.nofixup.ur source
[source]
----
call $lex insert 0 '{
if { eq charAt 0 source "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



will result in


.nofixup.ur output
[source]
----
5
----




The sample `fixup.ur` first executes the `fixup` command.
The command then reads all the remaiing source code as input and replaces the input string with the list of the tokens.
After that the program inserts a new lexical analyser into the list `$lex` at the beginning.
This lexical analyser is NEVER invoked since the code is already tokenized.
Because of that the addition command presented as `add*`, which means it will read all the arguments until the end of the block, or an `{}` is found will add `3`, `2`, and `1`.

In the second case there is no `fixup`.
The syntax analyser fetches only as far from the input source string as needed and no more.
First the command `call` is identified by the built-in lexical analyser as a bare word and since it is a command it will be executed.
The command `call` will fetch the next two arguments to get the object and the method.
When it fetches the arguments the interpreter invokes the lexical analysers to get the arguments.
The rest of the input is not tokenized and is available as a string including and following the space before `0 '{`.
The arguments for the call are are `$lex` and `insert`.
Invoking `insert` on the list object advances the lexical analysis further.
The next argument is the position to insert a new value in the list, this is `0`.
The element to insert is a quoted block, which will be also tokenized and as a block command gets inserted into the list.

At this point the source code string contains the part that starts with `set q add* ...`.
As the execution advances it reads on but this time -- without detailing the intermediate steps -- it will also use the inserted lexical analyser.
When this analyser sees the new line it will replace it with an empty block in the source.
That was the source will be transformed on the fly to `set q add* 3 2 {}`.
The commands `1` and `{}` are executed and ignored.
Finally the result of the addition is printed.



=== if

If the first argument is true then the second argument is executed, otherwise the third argument is executed.

The command returns the value of the executed block.

The third argument may be missing, or be `{}`.
Note that it can only be missing if the `if` command is the last command of the program or a block.


=== list

Creates a list object.

The argument can be a block or a command.
When it is a block, then the commands in the block are evaluated individually and the results are added to the list.
If the argument is a single command, then the command is evaluated and the result is the initial single element of the list.

The list is also an object and has methods:


* first
* last
* rest
* get
* set
* insert
* length
* split


These are documented as commands, but you can invoke them as methods of the list object using the command `call`.

=== list.first

A method defined on every list object that returns the first element of the list.



=== list.get
A list method that gets an element of a list from a given position.
The position is zero based.

=== list.insert
A list method that inserts an element into a list at a given position.
The position is zero based.

=== list.last

A method defined on every list object that returns the last element of the list.
If the list is empty, then the command throws an exception.
The command is defined on the list object.
The command does not have any argument.
The command returns the last element of the list.

=== list.length
A list method that returns the length of the list.


=== list.rest
A list method that returns a new list that contains all the elements of the original list except the first one.
If the list is empty, then the command throws an exception.
The command is defined on the list object.
The command does not have any argument.

=== list.set
A list method that sets an element of a list at a given position.
The position is zero-based.

=== list.split
A list method that splits the list into two lists at a given index.
The index is zero-based.
The method returns a list of two lists.
The first list contains the elements from the beginning of the list up to the index.

=== object

Create a new object.
The argument is the parent object.
The new object will inherit all the fields from the parent object.
The inheritance happens using shallow copy.

If the arument is `{}` then the new object will be empty at the creation.

=== puts
Print the value as a string.

=== quote

Return the argument as a value without evaluating it.
The command can be used as `quote` but it is also abbreviated as `'`.

=== set
Set a variable in the context.

The first argument is the name of the variable and the second argument is the value.

=== setf
Set a field in an object.
The first argument is the object, the second argument is the name of the field, and the third argument is the value.

=== setg
Set a global variable in the context.
The first argument is the name of the variable, and the second argument is the value.

=== sets

Set the remaining source that was not processed yet.

=== shift

Get the argument following the block with evaluation.


=== source
Get the remaining source that was not processed yet.

=== while

The first argument is the condition and the second argument is the block.
The command executes the two blocks one after the other while the result of the first block is true.



== Redefining the Language

The language can redefine itself.
Since the end of the code is not tokenized and is available as a string, you can write code that modifies the source extending the original syntax.
The following example will treat every new line as a command closing empty block.

The operator commands, like `add`, `mult`, `div` and so on can either take two arguments or multiple arguments.
If their first argument is  `*` they will take all the remaining arguments until the end of the block or until an empty block is the next argument.

Writing `{}` many times at the end of the operands following an `add` or `mult` may be cumbersome.
To avoid this, the following program alters the syntax analysis process to treat every new line as a command closing an empty block.


.lexNewLine.ur source
[source]
----
call $lex insert 0 '{
if { eq charAt 0 source "\n"}
   {sets add "{}" substring 1 length source source}}
set q add* 3 2
1 {} puts q

----



The variable `$lex` is a list that contains all the lexical analyzers.
Lexical analyzers are commands that get the source and either

* return a single token and swallow the characters corresponding to that token from the source, or

* leave the source intact and return `null`.

The code inserts a new lexical analyzer.
This analyzer looks at the start of the source.
If it is a new line, it removes that and inserts an empty block instead.
After that it returns `null`, like if it did not find anything.

The new lexical analyzer is inserted at the beginning of the list.
After this the command `add* 3 2\n` will be treated as `add* 3 2 {}`.
That way this program will result in:


.lexNewLine.ur output
[source]
----
5
----