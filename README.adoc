= Ouroboros

image::logo.svg[Ouroboros logo, align="left" width=100]


A minimal interpreter for a minimal language.
Ouroboros was inspired by TCL, LISP and Forth.




== Introduction

This interpreter is executing the simplest syntax possible.
A program is nothing else than a list of tokens.
A bare word can represent a variable or a function.
When a function is called, it can consume the subsequent tokens.

=== `puts` writing the output

For example:


.oro source
[source]
----
puts "Hello, World!"

----



will result in:


.Output
[source]
----
Hello, World!
----


`puts` is a function that prints its argument as a string.
The argument is the string "Hello, World!".
In this case this is a literal, but it can also be more complex, something to evaluate before outputting.

=== String concatenation

For example, the following sample:


.oro source
[source]
----
puts add "Hello, " "World!"

----



will result again in:


.Output
[source]
----
Hello, World!
----


In this case the expression is the concatenation of two strings.
As `puts` starts to execute it takes one argument.
Taking this argument recognizes `add` as a function.
`add` takes two arguments and if they are strings, it concatenates them.
Finally, the result is printed.

=== Variables

Variables can be assigned with the `set` command.
Variables are always local to the block they are defined in.
If you want to redefine a variable at the top level, you can use the `setg` command.
The name `setg` stands for "set global".

You can also set a field of an object with the `setf` command.
In this case the first parameter is the object, and the second is the field name followed by the value.

There is another set command `sets` that sets the remaining source code.
It is detailed later.

Example for the commands `set`, `setg` and `setf`:


.oro source
[source]
----
set a "Hello, "
{
  puts a
  puts "\n"
  set a "World!"
  puts a
  puts "\n"
  setg a "Gruetzi, "
  puts a
  puts "\n"
}
puts a

----



will result in:


.Output
[source]
----
Hello, 
World!
World!
Gruetzi, 
----


The first `puts` command prints "Hello, " using the global variabel `a`.
The second `puts` command prints "World!" using the local variable `a`.

After this we alter the global `a`, but while we are still in the block the next `puts` command still prints "World!".
Finally, stepping out of the block the last `puts` command prints "Gruetzi, ".

To set a field of an object is done using `setf`.
To do that, we need to have an object, that can be sone with the `object` command.


.oro source
[source]
----
set obj object {}
setf obj name "Hello, "
{
  puts field obj name
  puts "World!"
}

----



will result in:


.Output
[source]
----
Hello, World!
----


We set the variable `obj` to an object.
The argument of the command `object` is the parent object to inherit from.
In this case it is an empty block, so the object has no parent.
Blocks are explained in the section "Blocks".

Then we set the field `name` of the object to `"Hello, "`.
Finally, we print the field `name` of the object using the command `field` and `"World!"`.

==== Data types

The language handles any data type that commands can handle.
The commands that come with the interpreter build in handle `Long`, `Double`, `String` and `Boolean`, objects and lists off the shelf.


=== Blocks

A block is a series of commands one after the other surrounded by curly braces.
For example:


.oro source
[source]
----
puts {
  puts "Hello, "
  puts "World!"
}

----



will result in:


.Output
[source]
----
Hello, World!World!
----


The commands in the blocks are evaluated one ofter the other, and the value of the block is the value of the last command.
In this case the starting the first `puts` command it evaluates the block.
During the block evaluation the two `puts` commands are executed, and the result is the value of the last `puts` command.

`puts` results the string it printed out.

=== Objects, Functions and Methods

Objects are a collection of fields.
You can create an object with the `object` command.
The command has one argument, the parent object.
During creation the object will copy all fields from the parent object.
There are no classes, only objects.

Functions are nothing else than blocks assigned to a variable.
You can call a function by the name, and then it will evaluate the block.

However, you have to be careful.
If you assign a block to a variable, make sure that you assign the block and not the evaluated result of the block.
For example the following code will not work:


.oro source
[source]
----
set a { puts shift }
a "Hello, World!"

----



It will result in an exception:


.Output
[source]
----
Variable a is not defined
----


The reason is that the block is evaluated before it is assigned to the variable `a`.
During the evaluation it tries to get the next argument calling `shift` and that is `a`.
At this point `a` is not defined yet.

The correct example is:


.oro source
[source]
----
set a '{ puts shift }
a "Hello, World!"

----



that results in


.Output
[source]
----
Hello, World!
----


The command `quote` also abbreviated as `'` will fetch the next element without evaluating it.
It will be assigned as a block that will be evaluated when the variable is used as a command.

Methods are functions that are assigned to an object field.
They cannot be called directly.
To call a method, you need the command `call`.


.oro source
[source]
----
set a object{}
setf a b '{puts shift puts field this name puts "!"}
setf a name "World"
call a b "Hello, "

----



It will result in:


.Output
[source]
----
Hello, World!
----


The program defines an object and sets the variable `a` to the object.
Then it sets the field `b` of the object to a function.
After that is sets the field `name` of the object to `"World"`.
Finally, it calls the method `b` of the object `a` with the arguments `"Hello, "`.

When the call is executed, the interpreter will assign the objet to the variable `this`.

When you execute a block, the value of the block is the value of the last command in the block.
Every block has a local scope, and when you define a variable in a block, it is only available in this block.
There are two special variables that are always available inside a block: `$` and `pass:[$$]`.
`$` is an object representing the current block.
`pass:[$$]` is the surrounding block.
The fields of these objects are the variables of the block.

== Commands

Ouroboros comes with built-in commands.
The command set is minimal, but it can be extended.